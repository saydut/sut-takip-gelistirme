-- 1. AUDIT LOG TABLOSU
CREATE TABLE IF NOT EXISTS audit_logs (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sirket_id BIGINT REFERENCES sirketler(id),
    user_id BIGINT REFERENCES kullanicilar(id),
    islem_turu VARCHAR(20) NOT NULL, -- 'INSERT', 'UPDATE', 'DELETE', 'LOGIN' vb.
    tablo_adi VARCHAR(50),
    kayit_id BIGINT,
    detaylar JSONB, -- Eski veri, yeni veri, açıklama vs.
    ip_adresi VARCHAR(45),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('turkey', now())
);

-- Performans için index
CREATE INDEX IF NOT EXISTS idx_audit_sirket ON audit_logs(sirket_id);
CREATE INDEX IF NOT EXISTS idx_audit_created ON audit_logs(created_at DESC);


-- 2. ATOMIC TANKER GÜNCELLEME (Concurrency Çözümü)
-- Bu fonksiyon, okuma ve yazma arasındaki gecikmeyi ortadan kaldırır.
-- Tanker doluluğunu veritabanı seviyesinde atomik olarak artırır veya azaltır.

CREATE OR REPLACE FUNCTION atomic_tanker_update(
    p_tanker_id BIGINT,
    p_litre_change NUMERIC
)
RETURNS NUMERIC -- Yeni doluluk oranını döner
LANGUAGE plpgsql
SECURITY DEFINER -- Admin yetkisiyle çalışır (RLS'i aşmak için güvenli bağlamda)
AS $$
DECLARE
    v_yeni_doluluk NUMERIC;
    v_kapasite NUMERIC;
BEGIN
    -- Kapasite kontrolü
    SELECT kapasite_litre INTO v_kapasite 
    FROM tankerler 
    WHERE id = p_tanker_id;

    -- Güncelleme (Mevcut değer + değişim)
    UPDATE tankerler
    SET mevcut_doluluk = mevcut_doluluk + p_litre_change
    WHERE id = p_tanker_id
    RETURNING mevcut_doluluk INTO v_yeni_doluluk;

    -- Eksiye düşmeyi engelle (Opsiyonel güvenlik)
    IF v_yeni_doluluk < 0 THEN
        RAISE EXCEPTION 'Tanker doluluğu negatif olamaz!';
    END IF;
    
    -- Kapasite aşımı kontrolü (Sadece ekleme yapılıyorsa)
    IF p_litre_change > 0 AND v_yeni_doluluk > v_kapasite THEN
         RAISE EXCEPTION 'Tanker kapasitesi aşıldı!';
    END IF;

    RETURN v_yeni_doluluk;
END;
$$;